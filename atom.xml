<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PANGU</title>
  
  
  <link href="https://yunlongf.github.io/atom.xml" rel="self"/>
  
  <link href="https://yunlongf.github.io/"/>
  <updated>2022-11-22T06:30:14.218Z</updated>
  <id>https://yunlongf.github.io/</id>
  
  <author>
    <name>FuYunlong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Webgoat代码审计之目录遍历</title>
    <link href="https://yunlongf.github.io/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/"/>
    <id>https://yunlongf.github.io/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/</id>
    <published>2022-11-22T06:30:27.748Z</published>
    <updated>2022-11-22T06:30:14.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Path-traversal-lesson2"><a href="#Path-traversal-lesson2" class="headerlink" title="Path traversal- lesson2"></a>Path traversal- lesson2</h3><p>这边正常上传一张图片，抓包发现上传到的目录如下。</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221111170821931.png" alt="image-20221111170821931"></p><p>分析一下源代码：发现目标代码主要是利用注解来获取上传表单的 uploadFile 和 fullName 参数中的内容</p><p>然后下面的这行代码规定了我们上传的目录</p><p>/PathTraversal/用户名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">uploadDirectory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.webGoatHomeDirectory, <span class="string">&quot;/PathTraversal/&quot;</span> + webSession.getUserName());</span><br></pre></td></tr></table></figure><p>继续往下看我们的代码，发现会在上面定义的目录下新创建一个文件夹，主要是以fullname的名字来命名，就是这里也就是没有对fullname传进来的参数进行一个过滤才导致目录穿越</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uploadDirectory.mkdirs();</span><br><span class="line"><span class="comment">// 创建一个文件夹 文件夹名字为fullname，这里应该对fullname进行一个过滤</span></span><br><span class="line"><span class="type">var</span> <span class="variable">uploadedFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadDirectory, fullName);</span><br><span class="line"><span class="comment">// 直接进行文件夹的创建</span></span><br><span class="line">uploadedFile.createNewFile();</span><br><span class="line">FileCopyUtils.copy(file.getBytes(), uploadedFile);</span><br></pre></td></tr></table></figure><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103135609895.png" alt="image-20221103135609895"></p><p>如果在fullname前加上../即可跳转到上一目录</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103135530312.png" alt="image-20221103135530312"></p><p>知道漏洞点在哪里了“我们打断点来更加清晰的查看一下吧，我们正常的结果文件被上传到了/test下</p><p>我们来对fullname进行一个修改我们再来看看结果如何，将我们的fullname修改成 ../test</p><p>发现路径变成如下这样了，所以最终的上传路径就变成了</p><p>/User/Fuyunlong/.webgoat-8.2.1/PathTraversal/admin886/</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103140758768.png" alt="image-20221103140758768"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103140817325.png" alt="image-20221103140817325"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103140855175.png" alt="image-20221103140855175"></p><h3 id="Path-traversal-lesson3"><a href="#Path-traversal-lesson3" class="headerlink" title="Path traversal- lesson3"></a>Path traversal- lesson3</h3><p>这一关与前面不同的是，它将传入的fullname中的../置为空，所以如果直接加../那么将直接被置为空，也就无法完成目录遍历，此时尝试双写…/./<img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103141139691.png" alt="image-20221103141139691"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103141602955.png" alt="image-20221103141602955"></p><p>老规矩，找到源码打断点。</p><p>我们发现刚传入的文件名是…/./</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103142208767.png" alt="image-20221103142208767"></p><p>但是被文件名校验之后就变成了../,成功！</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103142314015.png" alt="image-20221103142314015"></p><h3 id="Path-traversal-lesson4"><a href="#Path-traversal-lesson4" class="headerlink" title="Path traversal- lesson4"></a>Path traversal- lesson4</h3><p>这次换了一个校验通过文件名来进行校验了</p><p>同样的文件名前面加 ../ 就可以绕过了</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103143734748.png" alt="image-20221103143734748"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103143812916.png" alt="image-20221103143812916"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103143936758.png" alt="image-20221103143936758"></p><h3 id="Path-traversal-lesson5"><a href="#Path-traversal-lesson5" class="headerlink" title="Path traversal- lesson5"></a>Path traversal- lesson5</h3><p>看题目的意思目录穿越还会存在在别的地方让我们来通过漏洞来找到jpg文件</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20201108161307271.png" alt="image-20201108161307271"></p><p>我这里直接审计源码做了，点击show randowm cat picture的时候，发现请求了 <code>/PathTraversal/random-picture</code>接口</p><p>直接在IDEA中进行全局搜索 ，找到如下文件</p><p>首先我们看到红框这里，后端代码会对我们传输过来的数值进行一个判断，如果里面包含 <code>..</code> 或者 <code>/</code> 就直接回显不合理的字符串</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103152528474.png" alt="image-20221103152528474"></p><p>尝试之后果然如此</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103152347354.png" alt="image-20221103152347354"></p><p>但是这里有个缺陷，就是是直接获取了我们id的参数数值，众所周知后端在获取参数值之后会进行一次url解码，所以我们可以利用url编码对 <code>../</code>进行一个编码从而绕过检测机制</p><p>利用burp来发送请求</p><p>通过打断点，发现成功绕过</p><p>queryParams 获取到的参数为 %2e%2e%2f</p><p>id 获取到参数会进行一次url解码 <code>../</code></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103165717903.png" alt="image-20221103165717903"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221104103145339.png" alt="image-20221104103145339"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221104103511159.png" alt="image-20221104103511159"></p><p>但是根据第83行，我们的文件后会加一个 .jpg</p><p>也就是说我们输入url编码后的 <code>../</code> 绕过校验的之后，后端收到的路径是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../../.jpg</span><br></pre></td></tr></table></figure><p>但是这样的路径为什么最后会列出上上层目录的文件名呢？我们来自己看一下是怎么走的</p><p>首先会判断我们id的参数值里面 是否存在 path-traversal-secret.jpg</p><p>然后来到下面一个判断，判断我们的catPicature是否存在，这时候我们的catPicture为</p><p><code>/Users/Fuyunlong/.webgoat-8.2.1/PathTraversal/cat/../../.jpg</code> 是存在的</p><p>然后就会来到return语句，我们来看我们红框框出来的地方，会通过base64编码我们的路径为catPictcure的图片内容，放在返回包中的body中作为内容，但是此时我们的路径是不存在图片的，所以该语句执行失败，来到下面的一个return</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221104103803939.png" alt="image-20221104103803939"></p><p>如下图，如果发现没有发现目标文件，就会获取 catPicature 路径的父文件夹，并且列出所有的文件，在返回包中的body中返回，这也就解释了为什么 路径为什么是 <code>/Users/Fuyunlong/.webgoat-8.2.1/PathTraversal/cat/../../.jpg</code> 这样也能获取上上层文件的文件名</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221115113857247.png" alt="image-20221115113857247"></p><p>所以我们只需要找到path-traversal-secret.jpg位置在哪就可以了，简单尝试之后发现文件并不存在上个文件夹</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221115114046939.png" alt="image-20221115114046939"></p><p>那么就再向上一个目录 ,不出所料发现了我们要的jpg</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221115114149464.png" alt="image-20221115114149464"></p><p>直接获取即可，然后将username加密之后就是flag 提交就行了</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221105144820238.png" alt="image-20221105144820238"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221105144847721.png" alt="image-20221105144847721"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221105144931190.png" alt="image-20221105144931190"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221105145825655.png" alt="image-20221105145825655"></p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><ol><li><strong>对传来的参数做过滤</strong></li></ol><p>需对用户提交的内容进行严格的过滤，这里主要指过滤目录跳转符、字符截断符、dir命令等，如“…/”和“~/”。</p><ol start="2"><li> <strong>采用白名单的形式，验证所有的输入</strong></li></ol><p>也就是限制用户请求资源，对于少量的文件(例如都是图像)，写正则表达式批量规范请求资源的白名单。</p><ol start="3"><li> <strong>文件名参数统一编码，标准化所有字符</strong></li></ol><p>对用户传过来的文件名参数进行统一编码，将所有字符转换成url编码，这样服务器不会解析成../，对包含恶意字符或者空字符的参数进行拒绝。</p><ol start="4"><li><strong>id随机数命名，持久化id:path数据库</strong></li></ol><p>文件路径保存至数据库，用户提交文件对应id访问文件，路径识别拼接都在后端。</p><ol start="5"><li><strong>下载文件前做权限判断，设置目录权限。</strong></li></ol><p>控制返回数据，保证返回数据不会泄露任何和服务器相关的隐私数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Path-traversal-lesson2&quot;&gt;&lt;a href=&quot;#Path-traversal-lesson2&quot; class=&quot;headerlink&quot; title=&quot;Path traversal- lesson2&quot;&gt;&lt;/a&gt;Path traversal- les</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Webgoat代码审计之SQL注入</title>
    <link href="https://yunlongf.github.io/2022/11/22/sql%E6%B3%A8%E5%85%A5/"/>
    <id>https://yunlongf.github.io/2022/11/22/sql%E6%B3%A8%E5%85%A5/</id>
    <published>2022-11-22T03:36:36.352Z</published>
    <updated>2022-11-22T06:31:01.867Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="SQL注入-intro-lesson-9"><a href="#SQL注入-intro-lesson-9" class="headerlink" title="SQL注入 (intro)lesson-9"></a>SQL注入 (intro)lesson-9</h3><p>​    来到第9关可以看到这里已经构造好了SQL语句，只需要我们选择即可，先随便选择一个发包请求根据请求的接口到源码中进行定位相关代码。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221111161747501.png" alt="image-20221111161747501"></p><p>来到源码后发现这边采用的直接拼接，SQL注入不出意外就有了，打个断点分析一下</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102104707245-16673572322811.png" alt="image-20221102104707245"></p><p>发现我们输入的内容没有经过任何过滤就直接拼接进去了。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102104908923.png" alt="image-20221102104908923"></p><p>SQL语句拼接完成，到此SQL注入成功。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102104941192.png" alt="image-20221102104941192"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102105025491.png" alt="image-20221102105025491"></p><h3 id="SQL注入-intro-lesson-10"><a href="#SQL注入-intro-lesson-10" class="headerlink" title="SQL注入 (intro)lesson-10"></a>SQL注入 (intro)lesson-10</h3><p>第十关依旧是给出了提示的SQL语句，老规矩先随便发个请求，看一下请求的接口方便在源码中定位。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221111161919007.png" alt="image-20221111161919007"></p><p>在源码中定位到这一关，发现login_count使用的是占位符？进行拼接不存在SQL注入，而accountName是直接拼接，不出意外注入点就是accountName了。老样子打断点分析。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102111554444.png" alt="image-20221102111554444"></p><p>SQL语句拼接成功，然后就可以看到我们所有的数据都回显出来了。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102111637126.png" alt="image-20221102111637126"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102110734817.png" alt="image-20221102110734817"></p><h3 id="sql注入-advanced-lesson5"><a href="#sql注入-advanced-lesson5" class="headerlink" title="sql注入(advanced)-lesson5"></a>sql注入(advanced)-lesson5</h3><p>来到这一关首先看到一个登录框，直接请求抓包找接口对应的源码。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221111162500639.png" alt="image-20221111162500639"></p><p>确定源码如下，居然都是用占位符？进行拼接，这还怎么注入，返回这一关重新看。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102112824533.png" alt="image-20221102112824533"></p><p>发现原来还有一个注册功能，我们去看看注册功能，发现在注册的时候进行了参数拼接，直接将username_reg带入到了sql语句，这里在注册的时候会首先将我们输入的用户名进行一个查询，如果查询有结果就会返回user.exists 如果没有的话就会返回user.created。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102113602284.png" alt="image-20221102113602284"></p><p>所以我们来看一下我们的SQL注入语句,我们的SQL语句是如下这样的，我们可以通过 &#39; 闭合前面的符号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;select userid from sql_challenge_users where userid = &#x27;&quot; <span class="operator">+</span> username_reg <span class="operator">+</span> &quot;&#x27;&quot;</span><br></pre></td></tr></table></figure><p>例如 ：</p><p>下面是闭合情况，那么我们如果根据回显信息来获取我们需要的tom的密码呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> userid <span class="keyword">from</span> sql_challenge_users <span class="keyword">where</span> userid <span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="operator">+</span> <span class="string">&#x27;tom&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="operator">+</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>我们可以采用类似布尔盲注的思路，前提得知已有tom这个账号</p><p><code>tom&#39; and &#39;1&#39;=&#39;2</code> 真 and 假 这样结果就是为假这样的话数据库查询就无法查找出信息，就会执行else语句显示user.created</p><p><code>tom&#39; and &#39;1&#39;=&#39;1</code> 真 and 真 这样结果就是为真数据库就会查询出结果，执行if语句回显user.exists</p><p>所以这里我们可以根据消息回显的不同来执行sql语句</p><p>我们来打一下断点分析一下,我们先来尝试假的 用户名为 tom’ and ‘1’=’2</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103083412031-16674356551801.png" alt="image-20221103083412031"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103083612496.png" alt="image-20221103083612496"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103084156134.png" alt="image-20221103084156134"></p><p>可以看到拼接成功后直接来到了else这里</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103084314475.png" alt="image-20221103084314475"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103084417366.png" alt="image-20221103084417366"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103084501032.png" alt="image-20221103084501032"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103084541778.png" alt="image-20221103084541778"></p><p>接下来尝试tom’ and ‘1’=’1 也就是真的情况 执行了if语句</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103085051209.png" alt="image-20221103085051209"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103085235040.png" alt="image-20221103085235040"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103085353489.png" alt="image-20221103085353489"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103085442952.png" alt="image-20221103085442952"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103090522482.png" alt="image-20221103090522482"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103091041423.png" alt="image-20221103091041423"></p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><ol><li><strong>参数传值</strong></li></ol><p>程序员在书写SQL语言时，禁止将变量直接写入到SQL语句，必须通过设置相应的参数来传递相关的变量。从而抑制SQL注入。数据输入不能直接嵌入到查询语句中。同时要过滤输入的内容，过滤掉不安全的输入数据。或者采用参数传值的方式传递输入变量，这样可以最大程度防范SQL注入攻击。</p><ol start="2"><li><strong>基础过滤与二次过滤</strong></li></ol><p>SQL注入攻击前，入侵者通过修改参数提交and等特殊字符，判断是否存在漏洞，然后通过select、update等各种字符编写SQL注入语句。因此防范SQL注入要对用户输入进行检查，确保数据输入的安全性，在具体检查输入或提交的变量时，对于单引号、双引号、冒号等字符进行转换或者过滤，从而有效防止SQL注入。</p><p>当然危险字符有很多，在获取用户输入提交参数时，首先要进行基础过滤，然后根据程序的功能及用户输入的可能性进行二次过滤，以确保系统的安全性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;SQL注入-intro-lesson-9&quot;&gt;&lt;a href=&quot;#SQL注入-intro-lesson-9&quot; class=&quot;headerlink&quot; title=&quot;SQL注入 (intro)lesson-9&quot;&gt;&lt;/a&gt;SQL注入 (intro)lesson-</summary>
      
    
    
    
    
  </entry>
  
</feed>
