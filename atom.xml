<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PANGU</title>
  
  
  <link href="https://yunlongf.github.io/atom.xml" rel="self"/>
  
  <link href="https://yunlongf.github.io/"/>
  <updated>2022-11-24T07:25:58.400Z</updated>
  <id>https://yunlongf.github.io/</id>
  
  <author>
    <name>FuYunlong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Webgoat代码审计之认证缺陷</title>
    <link href="https://yunlongf.github.io/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7/"/>
    <id>https://yunlongf.github.io/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7/</id>
    <published>2022-11-24T07:28:22.559Z</published>
    <updated>2022-11-24T07:25:58.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Authentication-Bypasses"><a href="#Authentication-Bypasses" class="headerlink" title="Authentication Bypasses"></a>Authentication Bypasses</h3><p>权限绕过，我们首先看到他给了一个样例，在进行安全校验对时候直接将对应请求包中的参数删掉就可以绕过了</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7/image-20221119171443591.png" alt="image-20221119171443591"></p><p>当然我们的案例不可能和上面一样直接删除就好了，我们直接从源码层面来进行分析</p><p>首先我们简单发一个请求，发现请求了后端的一个接口<code>/auth-bypass/verify-account</code>全局搜索接口名来到如下页面可以看到在接受请求之前会进行一个判断，判断我们的参数名中是否包含secQuestion这也就是为什么我们直接把参数删掉是不行的</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7/image-20221105152455453.png" alt="image-20221105152455453"></p><p>下面那个判断是为了防止我们看源码进行作弊的 可以看到源码中含有我们的答案，如果我们输入的答案和源码中一样的话,like 就会为true（这里的like相当于标志符）同时返回让我们不要作弊的消息</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7/image-20221105152736349.png" alt="image-20221105152736349"></p><p>继续往下来，核心的代码处是这里，如果这里if可以通过那么我们就可以绕过我们的校验了</p><p>我们来看一下这个校验账户的功能</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7/image-20221119171744595.png" alt="image-20221119171744595"></p><p>直接进行一个跟进</p><p>发现有3个if，任意一个if符合条件了就会返回false</p><p>我们来看一下这三个if</p><p>第一个if 主要是判断了我们前端传过来的校验参数是否是两个</p><p>第二个和第三个if都是判断数值是否相等和我们源码中的答案</p><p>但是这里明显逻辑是有疏忽的，可以看到他获取的是 secQuestion0 和 secQuestion1 参数对应的数值进行一个比对</p><p>那么如果我们传入的参数含有 secQuestion 但是又不是 secQuestion0 或 secQuestion1 不就可以对这个校验进行一个绕过了吗</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7/image-20221119172045359.png" alt="image-20221119172045359"></p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7/image-20221105155040808.png" alt="image-20221105155040808"></p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7/image-20221105155145878.png" alt="image-20221105155145878"></p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7/image-20221105155838752.png" alt="image-20221105155838752"></p><p>首先上面的这个权限绕过我觉得可以运用在平时漏洞挖掘的过程中，有的时候的一些验证码校验很有可能删除就可以通过了，之前还无法理解后端是怎么写的，现在后端想想其实就是后端只获取了对应参数的数值类似<code>verify</code> ，所以我们在burp的过程中删去这个参数就可以绕过了</p><p><code>username=test&amp;password=test&amp;verify=1233</code> 改成 <code>username=test&amp;password=test</code> 就可以了</p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><ol><li><p>我们后端限定前端传递过来的参数一定要含有verify，如果没有就进行报错或者显示不合法即可</p></li><li><p>当然利用签名也是一个很好的方法，签名能有效的防止传递过来的参数被修改，但是签名也有被破解的风险，所以最关键的还是后端要对传递过来的参数进行一个校验</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Authentication-Bypasses&quot;&gt;&lt;a href=&quot;#Authentication-Bypasses&quot; class=&quot;headerlink&quot; title=&quot;Authentication Bypasses&quot;&gt;&lt;/a&gt;Authentication By</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Webgoat代码审计之认证缺陷（JWT）</title>
    <link href="https://yunlongf.github.io/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/"/>
    <id>https://yunlongf.github.io/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/</id>
    <published>2022-11-24T07:28:22.557Z</published>
    <updated>2022-11-24T07:26:31.267Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JWT-Tokens-lesson1"><a href="#JWT-Tokens-lesson1" class="headerlink" title="JWT Tokens lesson1"></a>JWT Tokens lesson1</h3><h4 id="Jwt-Token-简介"><a href="#Jwt-Token-简介" class="headerlink" title="Jwt Token 简介"></a>Jwt Token 简介</h4><p>jwt的全称是JSON Web Token，主要是由三个部分组成 分别是header(头)、payload(载体)、signature(签名)，现在主要是用在跨域请求中，因为jwt中会携带我们的身份信息，所以我们在跨域请求的过程中会直接携带上</p><p>header 中定义我们签名校验的算法</p><p>payload 中是我们的一些信息</p><p>signature 签名主要是防止在传输过程中信息载体被篡改</p><p>通常的jwt sign 生成是如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、EncodeString = Base64(header).Base64(payload)</span><br><span class="line"><span class="number">2</span>、最终token = HS256(EncodeString,<span class="string">&quot;秘钥&quot;</span>)</span><br></pre></td></tr></table></figure><p><a href="https://jwt.io/">https://jwt.io/</a> 这个网站是一个非常好用的jwt破解的工具</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221119172629430.png" alt="image-20221119172629430"></p><h4 id="JWT-signing"><a href="#JWT-signing" class="headerlink" title="JWT signing"></a>JWT signing</h4><p>首先我们来看一下这个题目，题目的意思是要我们来重置这个投票，不过当前的用户是guest我们不能进行任何操作</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123212121581.png" alt="image-20221123212121581"></p><p>我们切换用户到其他用户，不过执行删除的过程中发现仍然无法进行删除，因为我们此时还不是admin用户</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123212311754.png" alt="image-20221123212311754"></p><p>我们burp看一下数据包，我们可以看到我们cookie中的access_token ，发现是jwttoken 我们来到之前的那个网站这样清楚一些</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123214557158.png" alt="image-20221123214557158"></p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123214624811.png" alt="image-20221123214624811"></p><p>来到我们的网站 ，发现 payload 信息载体中 我们的admin 对应的是 false ，所以我们的目标就是要把这里的false 改成true但是由于第三段的sign是防止篡改的</p><p>这里看网上大佬的文章说是将flase 修改成 true ，然后将头部的alg改成了None，同时删除第三段即可，简单试一下。</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123214815740.png" alt="image-20221123214815740"></p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123214735073.png" alt="image-20221123214735073"></p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123214747388.png" alt="image-20221123214747388"></p><h3 id="Refreshing-a-token"><a href="#Refreshing-a-token" class="headerlink" title="Refreshing a token"></a>Refreshing a token</h3><p>首先来看我们的题目，简单的讲一下</p><p>这里有logfile，能看到路由记录，路由记录里能看到tom 过期的token</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123215006336.png" alt="image-20221123215006336"></p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123215423272.png" alt="image-20221123215423272"></p><p>首先我们来直接结算一下发现果然是不行的</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123215531539.png" alt="image-20221123215531539"></p><p>那我们如果带上过期了的token呢 我们再试试 ，看到我们的回显发现已经显示我们的token已经过期了</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123215636088.png" alt="image-20221123215636088"></p><p>后面尝试了之前的方法把 jwt token 中的header中的算法置为None发现也不行，那就直接看源码</p><p>我们直接全局搜索 <code>/JWT/refresh/checkout</code>定位到如下的文件</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123220143577.png" alt="image-20221123220143577"></p><p>看了一下上下文，发现找到了账号密码</p><p>这里的登录是 json的格式，后端会对用户名密码进行一个校验，如果校验通过的话就生成jwt token 并且进行一个返回</p><p>由于这里账号密码都是写死的所以也就没有sql注入的可能性了</p><p>然后我们就根据源码进行请求的发送，这里注意修改content-type</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123221058100.png" alt="image-20221123221058100"></p><p>发现返回了正常的access_token</p><p>来到我们的jwt.io 进行解码，并且修改user对应的数值为tom</p><p>由于该网站算法如果改成none的话就没有数据了，所以我们讲数据复制到burp自行进行一个jwt加密</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123221224558.png" alt="image-20221123221224558"></p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123221340114.png" alt="image-20221123221340114"></p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123221355714.png" alt="image-20221123221355714"></p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20221123221330694.png" alt="image-20221123221330694"></p><h4 id="Jwt-Token-空加密算法绕过-代码分析"><a href="#Jwt-Token-空加密算法绕过-代码分析" class="headerlink" title="Jwt Token 空加密算法绕过 代码分析"></a>Jwt Token 空加密算法绕过 代码分析</h4><p>（搬运自：<a href="http://wjlshare.com/archives/1403%EF%BC%8C%E6%9C%89%E6%97%B6%E9%97%B4%E8%87%AA%E5%B7%B1%E5%86%8D%E4%BD%93%E9%AA%8C%E4%B8%80%E4%B8%8B%EF%BC%89">http://wjlshare.com/archives/1403，有时间自己再体验一下）</a></p><p>那么我们现在来看一下这一题和上一题为什么会出现jwt token 算法头中的alg 置 None 就行了</p><p>其实本质的问题就是，后端jwt的某个函数允许空加密算法，由于之前怎么都弄不清楚所以用springboot 简单的写了一个jwt 校验的例子</p><p>项目的结构如下</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20201111210538598.png" alt="image-20201111210538598"></p><p>Controller 层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.Jwt.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JwtUtils jwtUtils;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 来获取我们token中的数值</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/token&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getToken</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;testfail&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;testsuccess&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/generate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateToken</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtUtils.generateToken();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/valid&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">validToken</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> jwtUtils.validToken(token);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JwtUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.Jwt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.*;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.impl.TextCodec;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JWT_PASSWORD</span> <span class="operator">=</span> TextCodec.BASE64.encode(<span class="string">&quot;victory&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateToken</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jws</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .setIssuer(<span class="string">&quot;me&quot;</span>)</span><br><span class="line">                .setSubject(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">                .setAudience(<span class="string">&quot;you&quot;</span>)</span><br><span class="line">                .setId(UUID.randomUUID().toString()).signWith(io.jsonwebtoken.SignatureAlgorithm.HS512, JWT_PASSWORD).compact(); <span class="comment">//just an example id</span></span><br><span class="line">        System.out.println(jws);</span><br><span class="line">        <span class="keyword">return</span> jws;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">validToken</span><span class="params">(String jwttoken)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Jwt</span> <span class="variable">claimsJws</span> <span class="operator">=</span> Jwts.parser().setSigningKey(JWT_PASSWORD).parse(jwttoken);</span><br><span class="line">            <span class="comment">//OK, we can trust this JWT</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">            <span class="comment">//don&#x27;t trust the JWT!</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fail&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是测试项目所以很简陋233，就只是一个校验jwt是否有效的测试代码</p><p>这是我们有效的jwt token</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20201111210938119.png" alt="image-20201111210938119"></p><p>我们删除一位试试看是否是success ，这里我删了最后一位A 结果就是 fail 了</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20201111211135736.png" alt="image-20201111211135736"></p><p>然后我们直接将我们的签名进行删除</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20201111211036947.png" alt="image-20201111211036947"></p><p>发现照样是成功的</p><p>这里主要问题就出在这里，校验过程中的函数 parse</p><p>如果开发不小心手抖用成了parse，那么这时候校验jwt的时候将会允许Header头部的算法为None，那么自然签名就没有了</p><p>（不过我这边直接删除签名也可以，应该是签名没有默认算法为None了吧）</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20201111211203600.png" alt="image-20201111211203600"></p><p><strong>那么如何修复呢？</strong></p><p>其实也很简单，我们只需要将函数修改成 parseClaimsJws 就可以了，这样的话后端就会对签名进行校验了</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20201111211613652.png" alt="image-20201111211613652"></p><p>那么我们重新来看一下webgoat中的源代码</p><p>不出所料就是用了parse导致的</p><p>前三个challenge 由于都用了 parse，所以在解决方法上都可以通过删除签名同时置Header头中的alg为None来解决</p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20201111211816968.png" alt="image-20201111211816968"></p><p><img src="/2022/11/24/%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7%EF%BC%88JWT%EF%BC%89/image-20201111212151594.png" alt="image-20201111212151594"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JWT-Tokens-lesson1&quot;&gt;&lt;a href=&quot;#JWT-Tokens-lesson1&quot; class=&quot;headerlink&quot; title=&quot;JWT Tokens lesson1&quot;&gt;&lt;/a&gt;JWT Tokens lesson1&lt;/h3&gt;&lt;h4 id=&quot;J</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Webgoat代码审计之密码重置</title>
    <link href="https://yunlongf.github.io/2022/11/24/%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/"/>
    <id>https://yunlongf.github.io/2022/11/24/%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/</id>
    <published>2022-11-24T07:28:22.555Z</published>
    <updated>2022-11-24T07:31:07.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Security-questions"><a href="#Security-questions" class="headerlink" title="Security questions"></a>Security questions</h2><p>这题告诉了我们webgoat用户的安全问题，让我们找回别的用户tom或者admin</p><p><img src="/2022/11/24/%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/image-20221123223237146.png" alt="image-20221123223237146"></p><p>一开始还以为这里存在什么逻辑问题结果一看发现，其实这题就是爆破，爆破颜色就行了</p><p><img src="/2022/11/24/%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/image-20221105171243993.png" alt="image-20221105171243993"></p><h2 id="Creating-the-password-reset-link"><a href="#Creating-the-password-reset-link" class="headerlink" title="Creating the password reset link"></a>Creating the password reset link</h2><p>说实话这道题目还是蛮有意思的，这里由于要用到邮件系统，所以我还需要打开webwolf，这是webgoat自带的邮件系统</p><p>我们来看一下题目的意思，题目这里要求我们重置tom的密码，然后以tom的用户身份登录进去</p><p><img src="/2022/11/24/%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/image-20221123223529256.png" alt="image-20221123223529256"></p><p>我这里还是直接查看源码看一下可能存在的漏洞点在哪里</p><p>我们首先进行密码的重置看一下请求，然后后端直接进行一个搜索</p><p><img src="/2022/11/24/%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/image-20221105173737186.png" alt="image-20221105173737186"></p><p>定位到如下文件</p><p>我们看到我们红框的那行代码，可以发现后端获取了我们请求头中host的数值，然后在发送邮件的过程中引入了host</p><p><img src="/2022/11/24/%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/image-20221105173214839.png" alt="image-20221105173214839"></p><p>所以我们可以在这个host这里做文章</p><p>我们先正常来看一下，先重置一下我们自己账号的密码</p><p>在邮箱中我们收到了重置密码的邮件点击链接 ，发现url中最后的uuid就是我们当前的用户身份凭证</p><p><img src="/2022/11/24/%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/image-20221105173754068.png" alt="image-20221105173754068"></p><p><img src="/2022/11/24/%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/image-20221105173821885.png" alt="image-20221105173821885"></p><p>所以说我们如果能劫持他人的uuid那么我们就可以重置他人的密码了</p><p>所以大致流程如下：</p><ol><li>将host修改为我们自己可控的vps，这里我填了webwolf 也就是本地的邮件服务器，email还是<a href="mailto:&#x74;&#x6f;&#x6d;&#64;&#119;&#101;&#98;&#x67;&#111;&#97;&#116;&#x2d;&#99;&#108;&#111;&#117;&#x64;&#x2e;&#111;&#114;&#103;">&#x74;&#x6f;&#x6d;&#64;&#119;&#101;&#98;&#x67;&#111;&#97;&#116;&#x2d;&#99;&#108;&#111;&#117;&#x64;&#x2e;&#111;&#114;&#103;</a></li></ol><p><img src="/2022/11/24/%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/image-20221105173249477.png" alt="image-20221105173249477"></p><ol start="2"><li>这样邮件就发送到了 tom 的邮箱中了，同时找回密码的链接变成了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:<span class="number">9090</span>/WebGoat/PasswordReset/reset/reset-password/tom的uuid</span><br></pre></td></tr></table></figure><ol start="3"><li>然后到我们的邮件服务器中查看劫持到的uuid</li></ol><p><img src="/2022/11/24/%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/image-20221105173135055.png" alt="image-20221105173135055"></p><p>然后通过替换uuid 实现密码重置</p><p><img src="/2022/11/24/%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/image-20221105173358772.png" alt="image-20221105173358772"></p><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><p>修复起来其实很简单我们只需要固定我们的host就可以了，其实归根结底就是太相信用户的输入了，这也是很多安全问题存在的原因</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Security-questions&quot;&gt;&lt;a href=&quot;#Security-questions&quot; class=&quot;headerlink&quot; title=&quot;Security questions&quot;&gt;&lt;/a&gt;Security questions&lt;/h2&gt;&lt;p&gt;这题告诉了我</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Webgoat代码审计之XSS</title>
    <link href="https://yunlongf.github.io/2022/11/23/XSS/"/>
    <id>https://yunlongf.github.io/2022/11/23/XSS/</id>
    <published>2022-11-23T02:55:33.862Z</published>
    <updated>2022-11-23T02:55:15.763Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XSS-lesson7"><a href="#XSS-lesson7" class="headerlink" title="XSS-lesson7"></a>XSS-lesson7</h3><p>这里给了一个类似于购物车的表单提交功能，他这里放在了XSS漏洞下，那我们就从这里找XSS<img src="/2022/11/23/XSS/image-20221122103500703.png" alt="image-20221122103500703"></p><p><img src="/2022/11/23/XSS/image-20221108132635728.png" alt="image-20221108132635728"></p><p>可以看到，大概漏洞点在card number位置上，下面上代码寻找问题，抓包发现页面把表单提交了/WebGoat/CrossSiteScripting/attack5a文件，在文件里找了下，确定了该功能的执行类</p><p><img src="/2022/11/23/XSS/image-20221122103306753.png" alt="image-20221122103306753"></p><p>第27行可以看到，确实使field2的参数经过了一个小写转换+匹配，也就能证明之前两个输入框输入的命令不正确了</p><p>第66行可以看到，field1也就是card number参数，直接放到了执行语句中，没有经过过滤，所以造成插入的语句被解析</p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><ol><li>输入编码转义</li></ol><p>对输入的数据进行HTML转义，使其不会识别为可执行脚本</p><p>Spring HtmlUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> HtmlUtils.htmlEscape(field1);</span><br><span class="line">        cart.append(<span class="string">&quot;&lt;p&gt;We have charged credit card:&quot;</span> + result + <span class="string">&quot;&lt;br /&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>白名单过滤</li></ol><p>根据白名单的标签和属性对数据进行过滤，以此来对可执行的脚本进行清除(如script标签，img标签的onerror属性等)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.jsoup/jsoup --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.jsoup&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jsoup&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.13</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Jsoup.clean(source, Whitelist.basic());</span><br></pre></td></tr></table></figure><p><img src="/2022/11/23/XSS/image-20221123105353842.png" alt="image-20221123105353842"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;XSS-lesson7&quot;&gt;&lt;a href=&quot;#XSS-lesson7&quot; class=&quot;headerlink&quot; title=&quot;XSS-lesson7&quot;&gt;&lt;/a&gt;XSS-lesson7&lt;/h3&gt;&lt;p&gt;这里给了一个类似于购物车的表单提交功能，他这里放在了XSS漏洞下，那</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Webgoat代码审计之SSRF</title>
    <link href="https://yunlongf.github.io/2022/11/23/SSRF/"/>
    <id>https://yunlongf.github.io/2022/11/23/SSRF/</id>
    <published>2022-11-23T02:38:11.140Z</published>
    <updated>2022-11-23T02:37:55.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SSRF-lesson1"><a href="#SSRF-lesson1" class="headerlink" title="SSRF-lesson1"></a>SSRF-lesson1</h3><p>题目要求我们去找到jerry的图片</p><p><img src="/2022/11/23/SSRF/image-20221119165031495.png" alt="image-20221119165031495"></p><p>发现请求了images下的tom图片，我们修改为jerry就可以了</p><p><img src="/2022/11/23/SSRF/image-20221109125920656.png" alt="image-20221109125920656"></p><p>看了看后端代码发现就是一个简单的判断语句</p><p><img src="/2022/11/23/SSRF/image-20221109130001817.png" alt="image-20221109130001817"></p><h3 id="SSRF-lesson2"><a href="#SSRF-lesson2" class="headerlink" title="SSRF-lesson2"></a>SSRF-lesson2</h3><p>第二题让我们请求他给出的网址，也是很简单直接换成url即可</p><p><img src="/2022/11/23/SSRF/image-20221119165338162.png" alt="image-20221119165338162"></p><p><img src="/2022/11/23/SSRF/image-20221109130312897.png" alt="image-20221109130312897"></p><p><img src="/2022/11/23/SSRF/image-20221109130351811.png" alt="image-20221109130351811"></p><p><img src="/2022/11/23/SSRF/image-20221109130429412.png" alt="image-20221109130429412"></p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><ol><li>限制请求的端口只能为Web端口，只允许访问HTTP和HTTPS的请求。</li><li>限制不能访问内网的IP，以防止对内网进行攻击。</li><li>屏蔽返回的详细信息。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SSRF-lesson1&quot;&gt;&lt;a href=&quot;#SSRF-lesson1&quot; class=&quot;headerlink&quot; title=&quot;SSRF-lesson1&quot;&gt;&lt;/a&gt;SSRF-lesson1&lt;/h3&gt;&lt;p&gt;题目要求我们去找到jerry的图片&lt;/p&gt;
&lt;p&gt;&lt;img </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Webgoat代码审计之XXE</title>
    <link href="https://yunlongf.github.io/2022/11/23/XXE/"/>
    <id>https://yunlongf.github.io/2022/11/23/XXE/</id>
    <published>2022-11-23T02:32:16.244Z</published>
    <updated>2022-11-23T02:31:53.357Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XXE-lesson1"><a href="#XXE-lesson1" class="headerlink" title="XXE-lesson1"></a>XXE-lesson1</h3><p>我们直接来看一下题目</p><p>题目的意思是让我们列出root下的文件，这里只有一个评论的功能</p><p><img src="/2022/11/23/XXE/image-20221119165916926.png" alt="image-20221119165916926"></p><p>发现传输的格式是xml，很简单我们引入我们的dtd文件就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">       &lt;!ENTITY js SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p><img src="/2022/11/23/XXE/image-20221107170315147.png" alt="image-20221107170315147"></p><p><img src="/2022/11/23/XXE/image-20221107170255577.png" alt="image-20221107170255577"></p><p>首先我们得知道为什么会出现xxe的问题</p><p>这里分为三步</p><p>首先，我们的功能点得解析我们的xml格式的数据（也就是xml数据我们是可控的）</p><p>其次，得允许dtd实体的引入</p><p>那么我们接下来来看一下代码是哪里出现问题并且进行定位一下</p><p>路由是 <code>/xxe/simple</code> 直接全局搜索</p><p><img src="/2022/11/23/XXE/image-20221107213720943.png" alt="image-20221107213720943"></p><p>首先看到代码中，我们的评论是被Comment类封装的，然后利用Comments类中的parsexml来解析我们传递过去的xml格式的内容</p><p>跟过去看一下查看下面这段代码可以发现，我们能控制我们输入的xml 同时也没有对实体进行一个限定，所以导致我们传入的xml能被正常解析从而执行命令</p><p><img src="/2022/11/23/XXE/image-20221107213658486.png" alt="image-20221107213658486"></p><p><img src="/2022/11/23/XXE/image-20221107213139460.png" alt="image-20221107213139460"></p><p><img src="/2022/11/23/XXE/image-20221107213211264.png" alt="image-20221107213211264"></p><h3 id="Modern-REST-framework"><a href="#Modern-REST-framework" class="headerlink" title="Modern REST framework"></a>Modern REST framework</h3><p>改一下content-type就可以了</p><p><img src="/2022/11/23/XXE/image-20221107214928192.png" alt="image-20221107214928192"></p><p><img src="/2022/11/23/XXE/image-20221107215013875.png" alt="image-20221107215013875"></p><p><img src="/2022/11/23/XXE/image-20221107215046206.png" alt="image-20221107215046206"></p><p><img src="/2022/11/23/XXE/image-20221107215109152.png" alt="image-20221107215109152"></p><p><img src="/2022/11/23/XXE/image-20221107215129638.png" alt="image-20221107215129638"></p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><p>那么如何进行修复呢</p><p>其实也比较简单，就是添加两行代码就行了，将支持外部实体和支持dtd都给禁止了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> XXE;</span><br><span class="line"><span class="keyword">import</span> lombok.<span class="keyword">var</span>;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.JAXBContext;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.JAXBException;</span><br><span class="line"><span class="keyword">import</span> javax.xml.stream.XMLInputFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.stream.XMLStreamException;</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXERepair</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Repair</span><span class="params">()</span> <span class="keyword">throws</span> JAXBException, XMLStreamException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> <span class="string">&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;!DOCTYPE doc [ \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;!ENTITY xxe SYSTEM \&quot;file:///etc/passwd\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;]&gt;&lt;comment&gt;&lt;text&gt;&amp;xxe;&lt;/text&gt;&lt;/comment&gt;&quot;</span>;</span><br><span class="line">        <span class="type">var</span> <span class="variable">jc</span> <span class="operator">=</span> JAXBContext.newInstance(Comment.class);</span><br><span class="line">        <span class="comment">// 创建了我们的工厂 读取xml的一个工厂</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">xif</span> <span class="operator">=</span> XMLInputFactory.newInstance();</span><br><span class="line">        <span class="comment">// 不支持外部实体</span></span><br><span class="line">        xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 不支持dtd</span></span><br><span class="line">        xif.setProperty(XMLInputFactory.SUPPORT_DTD, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">var</span> <span class="variable">xsr</span> <span class="operator">=</span> xif.createXMLStreamReader(<span class="keyword">new</span> <span class="title class_">StringReader</span>(xml));</span><br><span class="line">        <span class="comment">// 将我们的xml 变成我们的java对象</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">unmarshaller</span> <span class="operator">=</span> jc.createUnmarshaller();</span><br><span class="line">        unmarshaller.unmarshal(xsr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JAXBException, XMLStreamException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">XXERepair</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XXERepair</span>();</span><br><span class="line">        test.Repair();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;XXE-lesson1&quot;&gt;&lt;a href=&quot;#XXE-lesson1&quot; class=&quot;headerlink&quot; title=&quot;XXE-lesson1&quot;&gt;&lt;/a&gt;XXE-lesson1&lt;/h3&gt;&lt;p&gt;我们直接来看一下题目&lt;/p&gt;
&lt;p&gt;题目的意思是让我们列出root下</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Webgoat代码审计之目录遍历</title>
    <link href="https://yunlongf.github.io/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/"/>
    <id>https://yunlongf.github.io/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/</id>
    <published>2022-11-22T06:30:27.748Z</published>
    <updated>2022-11-22T06:30:14.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Path-traversal-lesson2"><a href="#Path-traversal-lesson2" class="headerlink" title="Path traversal- lesson2"></a>Path traversal- lesson2</h3><p>这边正常上传一张图片，抓包发现上传到的目录如下。</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221111170821931.png" alt="image-20221111170821931"></p><p>分析一下源代码：发现目标代码主要是利用注解来获取上传表单的 uploadFile 和 fullName 参数中的内容</p><p>然后下面的这行代码规定了我们上传的目录</p><p>/PathTraversal/用户名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">uploadDirectory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.webGoatHomeDirectory, <span class="string">&quot;/PathTraversal/&quot;</span> + webSession.getUserName());</span><br></pre></td></tr></table></figure><p>继续往下看我们的代码，发现会在上面定义的目录下新创建一个文件夹，主要是以fullname的名字来命名，就是这里也就是没有对fullname传进来的参数进行一个过滤才导致目录穿越</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uploadDirectory.mkdirs();</span><br><span class="line"><span class="comment">// 创建一个文件夹 文件夹名字为fullname，这里应该对fullname进行一个过滤</span></span><br><span class="line"><span class="type">var</span> <span class="variable">uploadedFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadDirectory, fullName);</span><br><span class="line"><span class="comment">// 直接进行文件夹的创建</span></span><br><span class="line">uploadedFile.createNewFile();</span><br><span class="line">FileCopyUtils.copy(file.getBytes(), uploadedFile);</span><br></pre></td></tr></table></figure><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103135609895.png" alt="image-20221103135609895"></p><p>如果在fullname前加上../即可跳转到上一目录</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103135530312.png" alt="image-20221103135530312"></p><p>知道漏洞点在哪里了“我们打断点来更加清晰的查看一下吧，我们正常的结果文件被上传到了/test下</p><p>我们来对fullname进行一个修改我们再来看看结果如何，将我们的fullname修改成 ../test</p><p>发现路径变成如下这样了，所以最终的上传路径就变成了</p><p>/User/Fuyunlong/.webgoat-8.2.1/PathTraversal/admin886/</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103140758768.png" alt="image-20221103140758768"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103140817325.png" alt="image-20221103140817325"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103140855175.png" alt="image-20221103140855175"></p><h3 id="Path-traversal-lesson3"><a href="#Path-traversal-lesson3" class="headerlink" title="Path traversal- lesson3"></a>Path traversal- lesson3</h3><p>这一关与前面不同的是，它将传入的fullname中的../置为空，所以如果直接加../那么将直接被置为空，也就无法完成目录遍历，此时尝试双写…/./<img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103141139691.png" alt="image-20221103141139691"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103141602955.png" alt="image-20221103141602955"></p><p>老规矩，找到源码打断点。</p><p>我们发现刚传入的文件名是…/./</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103142208767.png" alt="image-20221103142208767"></p><p>但是被文件名校验之后就变成了../,成功！</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103142314015.png" alt="image-20221103142314015"></p><h3 id="Path-traversal-lesson4"><a href="#Path-traversal-lesson4" class="headerlink" title="Path traversal- lesson4"></a>Path traversal- lesson4</h3><p>这次换了一个校验通过文件名来进行校验了</p><p>同样的文件名前面加 ../ 就可以绕过了</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103143734748.png" alt="image-20221103143734748"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103143812916.png" alt="image-20221103143812916"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103143936758.png" alt="image-20221103143936758"></p><h3 id="Path-traversal-lesson5"><a href="#Path-traversal-lesson5" class="headerlink" title="Path traversal- lesson5"></a>Path traversal- lesson5</h3><p>看题目的意思目录穿越还会存在在别的地方让我们来通过漏洞来找到jpg文件</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20201108161307271.png" alt="image-20201108161307271"></p><p>我这里直接审计源码做了，点击show randowm cat picture的时候，发现请求了 <code>/PathTraversal/random-picture</code>接口</p><p>直接在IDEA中进行全局搜索 ，找到如下文件</p><p>首先我们看到红框这里，后端代码会对我们传输过来的数值进行一个判断，如果里面包含 <code>..</code> 或者 <code>/</code> 就直接回显不合理的字符串</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103152528474.png" alt="image-20221103152528474"></p><p>尝试之后果然如此</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103152347354.png" alt="image-20221103152347354"></p><p>但是这里有个缺陷，就是是直接获取了我们id的参数数值，众所周知后端在获取参数值之后会进行一次url解码，所以我们可以利用url编码对 <code>../</code>进行一个编码从而绕过检测机制</p><p>利用burp来发送请求</p><p>通过打断点，发现成功绕过</p><p>queryParams 获取到的参数为 %2e%2e%2f</p><p>id 获取到参数会进行一次url解码 <code>../</code></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221103165717903.png" alt="image-20221103165717903"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221104103145339.png" alt="image-20221104103145339"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221104103511159.png" alt="image-20221104103511159"></p><p>但是根据第83行，我们的文件后会加一个 .jpg</p><p>也就是说我们输入url编码后的 <code>../</code> 绕过校验的之后，后端收到的路径是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../../.jpg</span><br></pre></td></tr></table></figure><p>但是这样的路径为什么最后会列出上上层目录的文件名呢？我们来自己看一下是怎么走的</p><p>首先会判断我们id的参数值里面 是否存在 path-traversal-secret.jpg</p><p>然后来到下面一个判断，判断我们的catPicature是否存在，这时候我们的catPicture为</p><p><code>/Users/Fuyunlong/.webgoat-8.2.1/PathTraversal/cat/../../.jpg</code> 是存在的</p><p>然后就会来到return语句，我们来看我们红框框出来的地方，会通过base64编码我们的路径为catPictcure的图片内容，放在返回包中的body中作为内容，但是此时我们的路径是不存在图片的，所以该语句执行失败，来到下面的一个return</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221104103803939.png" alt="image-20221104103803939"></p><p>如下图，如果发现没有发现目标文件，就会获取 catPicature 路径的父文件夹，并且列出所有的文件，在返回包中的body中返回，这也就解释了为什么 路径为什么是 <code>/Users/Fuyunlong/.webgoat-8.2.1/PathTraversal/cat/../../.jpg</code> 这样也能获取上上层文件的文件名</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221115113857247.png" alt="image-20221115113857247"></p><p>所以我们只需要找到path-traversal-secret.jpg位置在哪就可以了，简单尝试之后发现文件并不存在上个文件夹</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221115114046939.png" alt="image-20221115114046939"></p><p>那么就再向上一个目录 ,不出所料发现了我们要的jpg</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221115114149464.png" alt="image-20221115114149464"></p><p>直接获取即可，然后将username加密之后就是flag 提交就行了</p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221105144820238.png" alt="image-20221105144820238"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221105144847721.png" alt="image-20221105144847721"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221105144931190.png" alt="image-20221105144931190"></p><p><img src="/2022/11/22/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/image-20221105145825655.png" alt="image-20221105145825655"></p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><ol><li><strong>对传来的参数做过滤</strong></li></ol><p>需对用户提交的内容进行严格的过滤，这里主要指过滤目录跳转符、字符截断符、dir命令等，如“…/”和“~/”。</p><ol start="2"><li> <strong>采用白名单的形式，验证所有的输入</strong></li></ol><p>也就是限制用户请求资源，对于少量的文件(例如都是图像)，写正则表达式批量规范请求资源的白名单。</p><ol start="3"><li> <strong>文件名参数统一编码，标准化所有字符</strong></li></ol><p>对用户传过来的文件名参数进行统一编码，将所有字符转换成url编码，这样服务器不会解析成../，对包含恶意字符或者空字符的参数进行拒绝。</p><ol start="4"><li><strong>id随机数命名，持久化id:path数据库</strong></li></ol><p>文件路径保存至数据库，用户提交文件对应id访问文件，路径识别拼接都在后端。</p><ol start="5"><li><strong>下载文件前做权限判断，设置目录权限。</strong></li></ol><p>控制返回数据，保证返回数据不会泄露任何和服务器相关的隐私数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Path-traversal-lesson2&quot;&gt;&lt;a href=&quot;#Path-traversal-lesson2&quot; class=&quot;headerlink&quot; title=&quot;Path traversal- lesson2&quot;&gt;&lt;/a&gt;Path traversal- les</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Webgoat代码审计之SQL注入</title>
    <link href="https://yunlongf.github.io/2022/11/22/sql%E6%B3%A8%E5%85%A5/"/>
    <id>https://yunlongf.github.io/2022/11/22/sql%E6%B3%A8%E5%85%A5/</id>
    <published>2022-11-22T03:36:36.352Z</published>
    <updated>2022-11-22T06:31:01.867Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="SQL注入-intro-lesson-9"><a href="#SQL注入-intro-lesson-9" class="headerlink" title="SQL注入 (intro)lesson-9"></a>SQL注入 (intro)lesson-9</h3><p>​    来到第9关可以看到这里已经构造好了SQL语句，只需要我们选择即可，先随便选择一个发包请求根据请求的接口到源码中进行定位相关代码。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221111161747501.png" alt="image-20221111161747501"></p><p>来到源码后发现这边采用的直接拼接，SQL注入不出意外就有了，打个断点分析一下</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102104707245-16673572322811.png" alt="image-20221102104707245"></p><p>发现我们输入的内容没有经过任何过滤就直接拼接进去了。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102104908923.png" alt="image-20221102104908923"></p><p>SQL语句拼接完成，到此SQL注入成功。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102104941192.png" alt="image-20221102104941192"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102105025491.png" alt="image-20221102105025491"></p><h3 id="SQL注入-intro-lesson-10"><a href="#SQL注入-intro-lesson-10" class="headerlink" title="SQL注入 (intro)lesson-10"></a>SQL注入 (intro)lesson-10</h3><p>第十关依旧是给出了提示的SQL语句，老规矩先随便发个请求，看一下请求的接口方便在源码中定位。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221111161919007.png" alt="image-20221111161919007"></p><p>在源码中定位到这一关，发现login_count使用的是占位符？进行拼接不存在SQL注入，而accountName是直接拼接，不出意外注入点就是accountName了。老样子打断点分析。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102111554444.png" alt="image-20221102111554444"></p><p>SQL语句拼接成功，然后就可以看到我们所有的数据都回显出来了。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102111637126.png" alt="image-20221102111637126"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102110734817.png" alt="image-20221102110734817"></p><h3 id="sql注入-advanced-lesson5"><a href="#sql注入-advanced-lesson5" class="headerlink" title="sql注入(advanced)-lesson5"></a>sql注入(advanced)-lesson5</h3><p>来到这一关首先看到一个登录框，直接请求抓包找接口对应的源码。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221111162500639.png" alt="image-20221111162500639"></p><p>确定源码如下，居然都是用占位符？进行拼接，这还怎么注入，返回这一关重新看。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102112824533.png" alt="image-20221102112824533"></p><p>发现原来还有一个注册功能，我们去看看注册功能，发现在注册的时候进行了参数拼接，直接将username_reg带入到了sql语句，这里在注册的时候会首先将我们输入的用户名进行一个查询，如果查询有结果就会返回user.exists 如果没有的话就会返回user.created。</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221102113602284.png" alt="image-20221102113602284"></p><p>所以我们来看一下我们的SQL注入语句,我们的SQL语句是如下这样的，我们可以通过 &#39; 闭合前面的符号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;select userid from sql_challenge_users where userid = &#x27;&quot; <span class="operator">+</span> username_reg <span class="operator">+</span> &quot;&#x27;&quot;</span><br></pre></td></tr></table></figure><p>例如 ：</p><p>下面是闭合情况，那么我们如果根据回显信息来获取我们需要的tom的密码呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> userid <span class="keyword">from</span> sql_challenge_users <span class="keyword">where</span> userid <span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="operator">+</span> <span class="string">&#x27;tom&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="operator">+</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>我们可以采用类似布尔盲注的思路，前提得知已有tom这个账号</p><p><code>tom&#39; and &#39;1&#39;=&#39;2</code> 真 and 假 这样结果就是为假这样的话数据库查询就无法查找出信息，就会执行else语句显示user.created</p><p><code>tom&#39; and &#39;1&#39;=&#39;1</code> 真 and 真 这样结果就是为真数据库就会查询出结果，执行if语句回显user.exists</p><p>所以这里我们可以根据消息回显的不同来执行sql语句</p><p>我们来打一下断点分析一下,我们先来尝试假的 用户名为 tom’ and ‘1’=’2</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103083412031-16674356551801.png" alt="image-20221103083412031"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103083612496.png" alt="image-20221103083612496"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103084156134.png" alt="image-20221103084156134"></p><p>可以看到拼接成功后直接来到了else这里</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103084314475.png" alt="image-20221103084314475"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103084417366.png" alt="image-20221103084417366"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103084501032.png" alt="image-20221103084501032"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103084541778.png" alt="image-20221103084541778"></p><p>接下来尝试tom’ and ‘1’=’1 也就是真的情况 执行了if语句</p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103085051209.png" alt="image-20221103085051209"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103085235040.png" alt="image-20221103085235040"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103085353489.png" alt="image-20221103085353489"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103085442952.png" alt="image-20221103085442952"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103090522482.png" alt="image-20221103090522482"></p><p><img src="/2022/11/22/sql%E6%B3%A8%E5%85%A5/image-20221103091041423.png" alt="image-20221103091041423"></p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><ol><li><strong>参数传值</strong></li></ol><p>程序员在书写SQL语言时，禁止将变量直接写入到SQL语句，必须通过设置相应的参数来传递相关的变量。从而抑制SQL注入。数据输入不能直接嵌入到查询语句中。同时要过滤输入的内容，过滤掉不安全的输入数据。或者采用参数传值的方式传递输入变量，这样可以最大程度防范SQL注入攻击。</p><ol start="2"><li><strong>基础过滤与二次过滤</strong></li></ol><p>SQL注入攻击前，入侵者通过修改参数提交and等特殊字符，判断是否存在漏洞，然后通过select、update等各种字符编写SQL注入语句。因此防范SQL注入要对用户输入进行检查，确保数据输入的安全性，在具体检查输入或提交的变量时，对于单引号、双引号、冒号等字符进行转换或者过滤，从而有效防止SQL注入。</p><p>当然危险字符有很多，在获取用户输入提交参数时，首先要进行基础过滤，然后根据程序的功能及用户输入的可能性进行二次过滤，以确保系统的安全性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;SQL注入-intro-lesson-9&quot;&gt;&lt;a href=&quot;#SQL注入-intro-lesson-9&quot; class=&quot;headerlink&quot; title=&quot;SQL注入 (intro)lesson-9&quot;&gt;&lt;/a&gt;SQL注入 (intro)lesson-</summary>
      
    
    
    
    
  </entry>
  
</feed>
